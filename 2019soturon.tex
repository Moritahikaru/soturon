\documentclass[12pt]{jarticle}
\usepackage[a4paper,text={155mm,230mm},centering]{geometry}
\usepackage{amssymb,amsmath,amsthm}
\usepackage[dvips]{graphicx}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{周波数スイープによるワイヤレス給電の最適動作周波数の探索について}
\chead{}
\rhead{\thepage}
\lfoot{}
\cfoot{}
\rfoot{森田光流}
\usepackage{fancybox}
\usepackage{listings,jlisting}
\usepackage{color}
\usepackage{ascmac, here, txfonts, txfonts}

\begin{document}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%表紙
\thispagestyle{empty}

\vspace*{20mm}
\begin{center}
	{\Large 令和元年度　環境ロボティクス学科　卒業論文}
\end{center}
\vspace{10mm}
\begin{center}
	{\Huge 周波数スイープによるワイヤレス給電の最適動作周波数の探索について}
\end{center}
\vspace{90mm}
\begin{center}
	{\Large 令和2年 (2020) 2月14日}
\end{center}
\begin{center}
	{\Large 森田　光流}
\end{center}
\begin{center}
	{\Large 指導教員：穂高一条教授}
\end{center}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%目次

\tableofcontents

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%本文

\section{緒言}
\subsection{背景}
ワイヤレス給電とは，導線や金属接点などを介さずに電力を送電，供給することが可能な給電方法である．これにより，従来の電源コードでの水によるショートや感電事故の回避，給電が困難な場所に機器がある場合でも給電することが可能，電子機器の利便性向上など利点が挙げられる．(参考文献：\cite{matuda}，\cite{nakamura}，\cite{rohm})ワイヤレス給電の利用としては，スマートフォンやモバイルバッテリーを置くだけで充電することができる充電器や，医療福祉ではペースメーカーへの電力供給の利用，工業や産業においてロボットアームなどにも活用され，今後様々な分野で注目されている．
\\ 
\subsection{研究目的}
最適動作周波数を探索するには，受電電力と送電電力を使った電力効率を求める必要がある．しかし，電力効率が高いだけでは最適動作周波数が適切であるとはいえない．受電側と送電側の元々の電力が小さい場合も電力効率が高いということが考えられる．それではワイヤレス給電が最適に動作しているとは考えられない．したがって，最適動作周波数は高効率かつ大電力が出力される周波数と定義される．本研究はワイヤレス給電の送電側，受電側の電力を周波数ー電力の周波数スイープで測定し測定されたデータをもとに最適動作周波数を見つけ出しこれを評価並びに考察することを主目的とする．周波数スイープで出力可能なプログラムの開発並びに1周波数の測定時間の決定を事前に行う．
\clearpage
\section{論文の構成}
\clearpage
\section{原理}

\section{実験内容}

\section{実験結果}

\section{考察}

\section{結論}

\section{今後の展望}

\clearpage
\section{謝辞}
 本研究の進行や本論文等の執筆にあたり，ご指導いただいた穂高一条教授に感謝の意を示すとともに深く御礼申し上げます．
また本研究を進めるにあたり多大なご指導・助言してくださった自動制御研究室の先輩方並びに，共に研究した同期のメンバー
にも感謝の意を示すとともに深く御礼申し上げます．最後になりましたが，お世話になりました宮崎大学工学部環境ロボティクス
学科の先生方，並びに大学関係各位の皆様に心より感謝し，ここに御礼申し上げます．

\begin{thebibliography}{50}
	\bibitem{matuda}松田一志：”ワイヤレス給電システムのための電力測定回路の開発”，宮崎大学学士論文，2018年度
	\bibitem{nakamura}中村裕馬：”ワイヤレス給電のための送電側100kHzプッシュプル回路”，宮崎大学学士論文，2018年度
	\bibitem{rohm}  ローム株式会社：”ワイヤレス給電とは”ーエレクトロニクス豆知識, https://www.rohm.co.jp/electronics-basics/wireless-charging/wireless-charging\_what1，最終アクセス：2019/1/20
	\bibitem{tkinter}keicode.com-技術入門シリーズ:"TkinterによるGUIプログラミング"ーPython入門,https://python.keicode.com/advanced/tkinter.php,　最終アクセス：2019/1/21
\end{thebibliography}
\clearpage
\section{付録}
\subsection{プログラムについて}
前章に示された通り先行研究では周波数を変更する方法で，わざわざArduinoのプログラムの一部を変更して再コンパイルさせ出力結果をシリアルモニターに表示させる方法であった．その面倒を省くためpythonを利用して周波数をarduinoに送り，arduinoの出力結果をデータに保存させるGUIを作成した．以下のプログラムはGUIで周波数をarduinoへシリアル通信で送信してarduinoに出力されたデータをシリアル通信でpython側に送るそれぞれGUIのpythonプログラムと送電側のマイコンのarduinoプログラム，受電側のarduinoプログラムである．なお，pythonのプログラムにおいてGUIを作成にtkinterを使用した．tkinterの使用方法並びにpythonの使い方については参考文献：\cite{tkinter}を参考にした．
\lstset{
	%プログラム言語(複数の言語に対応，C,C++も可)
	backgroundcolor={\color[gray]{.90}},
	breakindent = 10pt,
	basicstyle = \ttfamily\scriptsize,
	commentstyle = {\itshape \color[cmyk]{1,0.4,1,0}},
	classoffset = 1,
	keywordstyle = {\bfseries \color[cmyk]{0,1,0,0}},
	stringstyle = {\ttfamily \color[rgb]{0,0,1}},
	frame = TBrl,
	framesep = 5pt,
	numbers = left,
	stepnumber = 1,
	numberstyle = \tiny\sffamily,
	tabsize = 4,
	captionpos = t,
	showstringspaces = false
}

	
	%直接記入の場合
	\begin{lstlisting}[caption = GUIプログラム , label = program1]
	import time
	import serial
	import csv
	import tkinter as tk
	import tkinter.filedialog as tkFileDialog
	import tkinter.font as tkFont
	
	x=0
	L=[] #dataを保存
	fre=0 #測定範囲の最小値
	laf=0 #1目盛りの周波数
	data=0 #測定範囲の最大値
	ser1=0 #送電側のシリアル通信
	ser2=0 #受電側のシリアル通信
	t=1
	tm=0
	
	
	def maindef():
	global x
	global L
	global ser
	global fre
	global data
	global laf
	global ser1 
	global ser2
	global t
	global tm    
	
	if x==0:
	t=1#一応
	elif x==1:
	#データ受け取り、次の周波数を入力
	if float(fre) > float(laf):
	x=3
	else:
	
	ser1.write('a'.encode('ascii')) # arduinoへ開始の合図を送る。
	ser2.write('a'.encode('ascii'))
	ser1.write(fre.encode('ascii'))
	ser2.write(fre.encode('ascii'))
	ser1.flush() # バッファ内の待ちデータを送りきる。
	ser2.flush()
	print("send:"+fre+"kHz")
	L.append(fre+"kHz")
	x=2
	t=1
	elif x==2:
	line1 = ser1.readline().decode('ascii').rstrip()
	line2 = ser2.readline().decode('ascii').rstrip()
	line3 = str(round(float(line2) / float(line1),3))
	print(fre+" "+line1+" "+line2+" "+line3)
	L.append(fre+" "+line1+" "+line2+" "+line3)
	if t>=int(tm)*10:
	if float(fre)+float(data)*0.001 > float(laf) and float(laf) > float(fre):
	fre=laf
	else:
	fre=str(round(float(fre) + float(data)*0.001,3))
	x=1
	else:
	t=t+1
	
	elif x==3:
	#データを送らない、後始末
	stop_data()
	x=0
	elif x==4:
	line1 = ser1.readline().decode('ascii').rstrip()
	line2 = ser2.readline().decode('ascii').rstrip()
	line3 = str(round(float(line2) / float(line1),3))
	print(fre+" "+line1+" "+line2+" ")
	L.append(fre+" "+line1+" "+line2+" ")
	
	root.after(10,maindef)
	
	class Ser:
	def __init__(self):
	self.ser=None
	
	def start_connect(self):
	global ser1
	global ser2
	comport1='COM3' # arduino ideで調べてから。送電側
	comport2='COM4' #受電側必ずcomportは送電側受電側異なるものを使用
	tushinsokudo=57600 # arduinoのプログラムと一致させる。
	timeout=5# エラーになったときのために。とりあえず5秒で戻ってくる。
	ser1=self.ser
	ser2=self.ser
	ser1 = serial.Serial(comport1,tushinsokudo,timeout=timeout)
	ser2 = serial.Serial(comport2,tushinsokudo,timeout=timeout)
	time.sleep(2) # 1にするとダメ！短いほうがよい。各自試す。
	
	def send_com(self):
	global x
	global data
	global fre
	global laf
	global ser1
	global ser2
	global L
	global tm
	# v,u,sの文字列は、
	#ぞれぞれv.get(),u.get(),s.get()で取り出す。
	#下部send_entry内のTextvariableでデータ入力
	data=v.get()
	fre=u.get() 
	laf=s.get()
	tm=v1.get() 
	if data.isdecimal()==True and fre.isdecimal()==True and laf.isdecimal()==True and tm.isdecimal()==True:
	ser1.write('a'.encode('ascii')) # arduinoへ開始の合図を送る。
	ser2.write('a'.encode('ascii'))
	ser1.write(fre.encode('ascii'))
	ser2.write(fre.encode('ascii'))#送電側と受電側の送るデータの量を合わせるため，
	#あえて周波数を送る.送らなかった場合，送電側と受電側の出力にずれが生じるから．
	ser1.flush() # バッファ内の待ちデータを送りきる。
	ser2.flush()
	print("send incease_fre:"+data+" first_fre:"+fre+" last_fre:"+laf)
	print("frequency transmission_ep receiving_ep power_efficiency")
	L.append("increase_frequency:"+data+" first_frequency:"+fre+" last_frequency:"+laf)
	L.append("frequency transmission_ep receiving_ep power_efficiency")
	print("send:"+fre+"kHz")
	L.append(fre+"kHz")
	
	if float(data)==0.0:
	x=4
	else:
	x=2
	t=1
	else:
	print("error")
	v.set("")
	u.set("")
	s.set("")
	v1.set("")
	def stop_com(self):
	global x
	x=3
	
	
	def connect(self):
	self.start_connect()
	send_button.configure(state=tk.NORMAL)
	stop_button.configure(state=tk.NORMAL)
	send_entry.configure(state=tk.NORMAL)
	defalt_entry.configure(state=tk.NORMAL)
	saveas_button.configure(state=tk.NORMAL)
	max_entry.configure(state=tk.NORMAL)
	time_entry.configure(state=tk.NORMAL)
	connect_button.configure(state=tk.DISABLED)
	
	def saveas():
	global L
	filename=tkFileDialog.asksaveasfilename(defaultextension=".csv",filetypes=[("csv","*.csv*")])
	
	with open(filename,'w') as fout:
	fout.write("\n".join(L))
	#周波数をclock_genelaterに送る
	#ストップするときの関数
	def stop_data():
	global ser1
	global ser2
	global fre
	ser1.write('b'.encode('ascii')) # arduinoへ終了の合図を送る。
	ser2.write('b'.encode('ascii'))
	ser1.flush() # バッファ内の待ちデータを送りきる。
	ser2.flush()
	ser1
	print("--stop--")
	L.append("stop")
	fre='0'
	time.sleep(1)
	
	root=tk.Tk()
	font=tkFont.Font(size=24)
	ser=Ser() 
	v=tk.StringVar() # tk.TK()の後に書く。
	u=tk.StringVar()
	s=tk.StringVar()
	v1=tk.StringVar()
	#ボタン入力
	connect_button=tk.Button(root,text='connect',font=font,height=2,padx=20,command=ser.connect)
	connect_button.grid(row=0,column=0)
	send_button=tk.Button(root,text='send',font=font,height=2,padx=20,command=ser.send_com)
	send_button.grid(row=0,column=1)
	send_button.configure(state=tk.DISABLED)
	stop_button=tk.Button(root,text='stop',font=font,height=2,padx=20,command=ser.stop_com)
	stop_button.grid(row=0,column=2)
	stop_button.configure(state=tk.DISABLED)
	#entry
	send_entry=tk.Entry(root,font=font,textvariable=v)
	send_entry.grid(row=1,column=1,columnspan=2)
	send_entry.configure(state=tk.DISABLED)
	defalt_entry=tk.Entry(root,font=font,textvariable=u)
	defalt_entry.grid(row=2,column=1,columnspan=2)
	defalt_entry.configure(state=tk.DISABLED)
	max_entry=tk.Entry(root,font=font,textvariable=s)
	max_entry.grid(row=3,column=1,columnspan=2)
	max_entry.configure(state=tk.DISABLED)
	time_entry=tk.Entry(root,font=font,textvariable=v1)
	time_entry.grid(row=4,column=1,columnspan=2)
	time_entry.configure(state=tk.DISABLED)
	
	#label
	label1=tk.Label(root,font=font,text='increase_frequency')
	label1.grid(row=1,column=0)
	label1_Hz=tk.Label(root,font=font,text='Hz')
	label1_Hz.grid(row=1,column=3)
	label2=tk.Label(root,font=font,text='first_frequency')
	label2.grid(row=2,column=0)
	label2_Hz=tk.Label(root,font=font,text='kHz')
	label2_Hz.grid(row=2,column=3)
	label3=tk.Label(root,font=font,text='last_frequency')
	label3.grid(row=3,column=0)
	label3_Hz=tk.Label(root,font=font,text='kHz')
	label3_Hz.grid(row=3,column=3)
	label4_time=tk.Label(root,font=font,text='Measurement_Time')
	label4_second=tk.Label(root,font=font,text='s')
	label4_time.grid(row=4,column=0)
	label4_second.grid(row=4,column=3)
	
	#セーブボタン
	saveas_button=tk.Button(root,text='save',font=font,height=2,padx=20,command=saveas)
	saveas_button.grid(row=0,column=3)
	saveas_button.configure(state=tk.DISABLED)
	
	root.after(100,maindef)
	root.mainloop()   
	
	
	\end{lstlisting}
	\begin{lstlisting}[caption=送電側arduino, label=program2]
	#include <si5351.h>
	#include <Wire.h>
	#include<MsTimer2.h>
	Si5351 si5351;
	
	unsigned long long freq = 5000000ULL;         
	  /*出力周波数50kHz(これをいじって周波数を変える)freq×0.01=周波数Hz*/
	unsigned long long pll_freq = 70500000000ULL;   
	/*PLL周波数(いじるな)*/
	
	String data;
	float data0 = 0;
	float f = 0;
	
	void setup() {
	
	Serial.begin(57600);
	MsTimer2::set(100, flash);
	
	bool i2c_found;                                        
	 /*I2C通信ができるかどうかブール値を入れる変数*/
	i2c_found = si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0); 
	 /*I2C通信を確認(ライブラリreadme参照)*/
	if (!i2c_found) {
	Serial.println("Error:I2C");
	}
	
	si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0);             
	/*振動子負荷容量(使うモジュールが8pFなのでこれ)*/
	si5351.set_freq_manual(freq, pll_freq, SI5351_CLK0); 
	   /*出力周波数,PLL周波数,設定先出力ピン設定*/
	si5351.set_phase(SI5351_CLK0, 0);                      
	 /*位相(今回特に意味はない)*/
	si5351.pll_reset(SI5351_PLLA);                         
	 /*PLLをリセット（使う前に一回リセット）*/
	si5351.update_status();                                
	 /*si5351のステータスを読む(今回特に使っていない)*/
	
	while (Serial.available() == 0);
	}
	
	
	
	
	void flash(void) {
	int i = analogRead(0);
	f = i * 5.0 / 1023.0;
	Serial.println(f);
	}
	
	void loop() {
	char aizu = Serial.read();
	if (aizu == 'a') {
	MsTimer2::stop();
	 //新しいduty比に変更されるまでflash関数を止める
	aizu = 'c';
	receive_duty_data();
	MsTimer2::start();
	}
	
	else if (aizu == 'b') {
	MsTimer2::stop();
	si5351.set_freq(400000, SI5351_CLK0);  
	  /*信号を止める*/          
	    /*!!!!!set_freq(0)!!!これでは止まらない!!!!!*/
	}
	
	else if (aizu == 'c') {
	//pass
	}
	}
	
	void receive_duty_data() {
	data = Serial.readString();
	data0 = data.toFloat();
	unsigned long long freq = data0 * 100000;
	 /*1=0.01Hzなので末尾に00をつける.入力単位をキロにしたいので末尾に10^3をつける．*/
	si5351.set_freq(freq, SI5351_CLK0);      
	 /*周波数セット*/
	si5351.pll_reset(SI5351_PLLA);           
	 /*念のためPLLをリセット*/
	si5351.update_status();
	}
	
	\end{lstlisting}
	\begin{lstlisting}[caption=受電側arduino, label=program3]
	#include<MsTimer2.h>
	
	float f = 0;
	String data;
	float data0 = 0;
	
	void setup() {
	Serial.begin(57600);
	MsTimer2::set(100,flash);
	while(Serial.available() == 0);
	}
	
	void flash(void){
	int i = analogRead(0);
	f = i * 5.0 / 1023.0;
	Serial.println(f);
	}
	
	void loop() {
	char aizu = Serial.read();
	
	if(aizu == 'a'){
	MsTimer2::stop();
	aizu = 'c';
	receive_duty_data();
	MsTimer2::start();
	}
	
	else if(aizu == 'b'){
	MsTimer2::stop();
	aizu='c';
	}
	
	}
	
	void receive_duty_data() {
	
	data = Serial.readString();
	data0 = data.toFloat();
	}
	\end{lstlisting}
	% ソースコードが別ファイルの場合

\end{document}

